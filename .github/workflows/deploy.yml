name: Deploy to EC2

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
  workflow_dispatch:
    inputs:
      target_env:
        description: "Target environment (dev or staging)"
        required: false
        default: "staging"
      reset_rds:
        description: "Set to true to reset RDS (dev/staging only)"
        required: false
        default: "false"
      confirm_reset:
        description: 'Type RESET to confirm destructive RDS reset'
        required: false
        default: ""

jobs:
  deploy:
    name: Deploy Backend to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: (Optional) Reset RDS schema for dev/staging
        if: >
          github.event_name == 'workflow_dispatch' &&
          inputs.reset_rds == 'true' &&
          inputs.confirm_reset == 'RESET' &&
          (inputs.target_env == 'dev' || inputs.target_env == 'staging')
        env:
          PGHOST: ${{ secrets.RDS_HOST }}
          PGPORT: ${{ secrets.RDS_PORT || '5432' }}
          PGDATABASE: ${{ secrets.RDS_DB }}
          PGUSER: ${{ secrets.RDS_USER }}
          PGPASSWORD: ${{ secrets.RDS_PASSWORD }}
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          echo "‚ö†Ô∏è  Resetting RDS schema for ${{ inputs.target_env }}..."
          psql "sslmode=require" -v ON_ERROR_STOP=1 <<'SQL'
          DROP SCHEMA public CASCADE;
          CREATE SCHEMA public;
          GRANT ALL ON SCHEMA public TO $PGUSER;
          GRANT ALL ON SCHEMA public TO public;
          SQL
          echo "‚úÖ Schema reset complete. Running Prisma migrations..."
          cd backend
          npm ci
          npx prisma migrate deploy
          echo "‚úÖ RDS reset and migrations applied for ${{ inputs.target_env }}"
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Generate Prisma Client
        working-directory: ./backend
        run: npx prisma generate
      
      - name: Build TypeScript
        working-directory: ./backend
        run: npm run build
      
      - name: Run tests
        working-directory: backend
        run: |
          echo "Skipping tests - requires database access not available in CI/CD"
          # Tests require RDS database connection which isn't accessible from GitHub Actions
          # Run tests manually on EC2 after deployment if needed
      
      # Temporarily disabled pre-deployment checks - Docker confirmed working on EC2
      # Re-enable after fixing permission issues
      # - name: Pre-deployment checks
      #   env:
      #     EC2_HOST: ${{ secrets.EC2_HOST }}
      #     EC2_USER: ${{ secrets.EC2_USER }}
      #     EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
      #   run: |
      #     # Setup SSH
      #     mkdir -p ~/.ssh
      #     echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key.pem
      #     chmod 600 ~/.ssh/deploy_key.pem
      #     ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts
      #     
      #     echo "üîç Running pre-deployment checks..."
      #     
      #     # Check EC2 connectivity and prerequisites
      #     ssh -i ~/.ssh/deploy_key.pem $EC2_USER@$EC2_HOST << 'ENDSSH'
      #       set -e  # Exit on error
      #       set -x  # Enable debug output
      #       
      #       echo "‚úÖ SSH connection successful"
      #       echo "Current user: $(whoami)"
      #       echo "Groups: $(groups)"
      #       
      #       # Check Docker
      #       echo "Checking if docker command exists..."
      #       if ! command -v docker &> /dev/null; then
      #         echo "‚ùå Docker is not installed"
      #         exit 1
      #       fi
      #       echo "‚úÖ Docker is installed: $(docker --version)"
      #       
      #       # Check if Docker daemon is running
      #       echo "Checking if Docker daemon is running..."
      #       echo "Attempting: docker ps"
      #       if ! sudo docker ps &> /dev/null; then
      #         echo "‚ùå Docker daemon is not running or user lacks permissions"
      #         echo "Trying to check docker service status..."
      #         sudo systemctl status docker || true
      #         exit 1
      #       fi
      #       echo "‚úÖ Docker daemon is running"
      #       
      #       # Check .env file exists (warning only, don't fail)
      #       if [ ! -f ~/backend/.env ]; then
      #         echo "‚ö†Ô∏è  Warning: .env file not found at ~/backend/.env"
      #         echo "   First deployment or .env needs to be created manually on EC2"
      #       else
      #         echo "‚úÖ .env file exists"
      #       fi
      #       
      #       # Check disk space (warning only, don't fail)
      #       DISK_USAGE=$(df -h ~ | awk 'NR==2 {print $5}' | sed 's/%//')
      #       echo "üìä Disk usage: ${DISK_USAGE}%"
      #       if [ "$DISK_USAGE" -gt 90 ]; then
      #         echo "‚ö†Ô∏è  Warning: Disk usage is high (${DISK_USAGE}%)"
      #       fi
      #       
      #       echo "‚úÖ Pre-deployment checks passed"
      #     ENDSSH
      
      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          # Validate required secrets
          if [ -z "$EC2_HOST" ] || [ -z "$EC2_USER" ] || [ -z "$EC2_SSH_KEY" ]; then
            echo "‚ùå Missing required secrets: EC2_HOST, EC2_USER, or EC2_SSH_KEY"
            exit 1
          fi
          
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key.pem
          chmod 600 ~/.ssh/deploy_key.pem
          ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connectivity first with timeout
          echo "üîç Testing SSH connectivity to EC2..."
          SSH_OPTS="-i ~/.ssh/deploy_key.pem -o ConnectTimeout=10 -o StrictHostKeyChecking=no"
          
          for i in {1..3}; do
            echo "Attempt $i of 3..."
            if timeout 15 ssh $SSH_OPTS $EC2_USER@$EC2_HOST 'echo "SSH connection successful"; whoami; pwd' 2>&1; then
              echo "‚úÖ SSH connection successful!"
              break
            else
              if [ $i -eq 3 ]; then
                echo "‚ùå SSH connection failed after 3 attempts"
                echo ""
                echo "Troubleshooting steps:"
                echo "1. Verify EC2 instance is running"
                echo "2. Check EC2 security group allows SSH (port 22) from GitHub Actions IPs"
                echo "3. Verify EC2_HOST secret is correct: $EC2_HOST"
                echo "4. Check EC2 instance status in AWS Console"
                exit 1
              fi
              echo "‚è≥ Waiting 5 seconds before retry..."
              sleep 5
            fi
          done
          
          echo "üì¶ Creating deployment package..."
          
          # Create deployment package
          cd backend
          tar -czf ../deploy.tar.gz \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='uploads' \
            --exclude='*.log' \
            --exclude='.deploy-trigger' \
            .
          
          echo "üì§ Uploading to EC2..."
          # Use timeout and retry for SCP
          for i in {1..3}; do
            echo "Upload attempt $i of 3..."
            if timeout 60 scp $SSH_OPTS ../deploy.tar.gz $EC2_USER@$EC2_HOST:/tmp/ 2>&1; then
              echo "‚úÖ File uploaded successfully!"
              break
            else
              if [ $i -eq 3 ]; then
                echo "‚ùå File upload failed after 3 attempts"
                exit 1
              fi
              echo "‚è≥ Waiting 5 seconds before retry..."
              sleep 5
            fi
          done
          
          echo ""
          echo "üîç Verifying uploaded file..."
          ssh $SSH_OPTS $EC2_USER@$EC2_HOST 'ls -lh /tmp/deploy.tar.gz' || {
            echo "‚ùå Uploaded file not found on EC2!"
            exit 1
          }
          
          echo "üöÄ Starting deployment on EC2..."
          echo ""
          
          # Execute deployment script on EC2
          set +e  # Don't exit on error, we want to capture it
          ssh $SSH_OPTS $EC2_USER@$EC2_HOST 'bash -s' << 'ENDSSH'
            set -x  # Enable verbose output
            
            echo "=== Starting Deployment ==="
            echo "üì¶ Extracting deployment package..."
            mkdir -p ~/backend_new || { echo "ERROR: Failed to create backend_new directory"; exit 1; }
            tar -xzf /tmp/deploy.tar.gz -C ~/backend_new || { echo "ERROR: Failed to extract deployment package"; exit 1; }
            rm /tmp/deploy.tar.gz || echo "Warning: Could not remove deploy.tar.gz"
            
            echo "üìã Copying environment file..."
            if [ -f ~/backend/.env ]; then
              cp ~/backend/.env ~/backend_new/.env && echo "‚úÖ .env file copied" || echo "Warning: Failed to copy .env"
            else
              echo "‚ö†Ô∏è  No .env file found at ~/backend/.env"
            fi
            
            echo "üöÄ Running deployment script..."
            cd ~/backend_new || { echo "ERROR: Failed to cd to backend_new"; exit 1; }
            chmod +x scripts/*.sh || { echo "ERROR: Failed to chmod scripts"; exit 1; }
            
            echo "=== Executing deploy.sh ==="
            ./scripts/deploy.sh
            DEPLOY_EXIT_CODE=$?
            
            if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
              echo "ERROR: deploy.sh failed with exit code $DEPLOY_EXIT_CODE"
              exit $DEPLOY_EXIT_CODE
            fi
            
            echo "üßπ Cleaning up old versions..."
            if [ -d ~/backend_old ]; then
              rm -rf ~/backend_old || echo "Warning: Could not remove backend_old"
            fi
            if [ -d ~/backend ]; then
              mv ~/backend ~/backend_old || echo "Warning: Could not move backend to backend_old"
            fi
            mv ~/backend_new ~/backend || { echo "ERROR: Failed to move backend_new to backend"; exit 1; }
            
            echo "‚úÖ Deployment completed successfully!"
          ENDSSH
          
          DEPLOYMENT_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          echo ""
          if [ $DEPLOYMENT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Deployment failed with exit code $DEPLOYMENT_EXIT_CODE"
            echo ""
            echo "üìã Fetching container logs from EC2..."
            ssh $SSH_OPTS $EC2_USER@$EC2_HOST 'if [ -d ~/backend_new ]; then echo "=== New container logs ==="; sudo docker logs trevel_admin_backend_new --tail 100 2>&1 || echo "No new container logs"; fi; if [ -d ~/backend ]; then echo "=== Current container logs ==="; sudo docker logs trevel_admin_backend --tail 50 2>&1 || echo "No current container logs"; fi' || true
            exit 1
          else
            echo "‚úÖ Deployment completed successfully!"
          fi
      
      - name: Verify deployment
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          echo "$EC2_SSH_KEY" > ~/.ssh/deploy_key.pem
          chmod 600 ~/.ssh/deploy_key.pem
          SSH_OPTS="-i ~/.ssh/deploy_key.pem -o ConnectTimeout=10 -o StrictHostKeyChecking=no"
          
          # Wait for service to stabilize
          sleep 10
          
          # Run health check
          ssh $SSH_OPTS $EC2_USER@$EC2_HOST << 'ENDSSH'
            cd ~/backend
            chmod +x scripts/health-check.sh
            ./scripts/health-check.sh
          ENDSSH
      
      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed! Check logs above for details."
          echo "The previous version should still be running."